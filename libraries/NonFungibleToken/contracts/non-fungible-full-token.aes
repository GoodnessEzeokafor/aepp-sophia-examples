include "math.aes"

contract NonFungibleFull =
  type token_id = int
  record state = { 
    name              : string,
    symbol            : string,
    owner             : address,
    owned_tokens_count  : map(address, int),
    token_owner        : map(token_id, address),
    token_approvals    : map(token_id, address),
    operator_approvals : map(address, map(address, bool)),
    token_uris         : map(token_id, string)}

  public stateful function  init(name : string, symbol : string) = {
  	name = name,
  	symbol = symbol,
    owner = Call.caller,
  	owned_tokens_count = {},
  	token_owner = {},
  	token_approvals = {},
    operator_approvals = {},
    token_uris = {}}

  public function get_caller() : address =
    Call.caller

  public function name() : string =
    state.name

  public function symbol() : string =
    state.symbol

  public function balance_of(token_owner : address) : int =
    Map.lookup_default(token_owner, state.owned_tokens_count, 0)

  public function owner_of(tokenId : token_id) : address =
    Map.lookup_default(tokenId, state.token_owner, #0)

  public function get_approved(tokenId : token_id) : address =
    Map.lookup_default(tokenId, state.token_approvals, #0)

  public function is_approved_for_all(_owner: address, operator : address) : bool =
    let operator_approvals' : map(address, bool) = Map.lookup_default(_owner, state.operator_approvals, {})
    Map.lookup_default(operator, operator_approvals', false)

  public function get_token_uri(tokenId : token_id) : string =
    Map.lookup_default(tokenId, state.token_uris, "")

  public stateful function set_token_uri(tokenId : token_id, uri : string) =
    only_token_owner(Call.caller, tokenId)
    put(state{ token_uris[tokenId] = uri })

  public stateful function mint(tokenId : token_id, to : address) = 
    only_owner(Call.caller)
    require(Map.lookup_default(tokenId, state.token_owner, #0) == #0, "Token can't be overrided")

    put(state{ 
      token_owner[tokenId] = to,
      owned_tokens_count[to] = SafeMath.add(Map.lookup_default(to, state.owned_tokens_count, 0), 1)})

  public stateful function burn(tokenId : token_id) = 
    only_token_owner(Call.caller, tokenId) 
    remove_token_from(Call.caller, tokenId)
    remove_token_metadata(tokenId)

  public stateful function approve(tokenId : int, to : address) =
    let _owner : address = owner_of(tokenId)
    
    require(to != Call.caller, "Receiver can't be same as sender")
    require(Call.caller == _owner || is_approved_for_all(_owner, Call.caller), "Not owner or not approved")
    
    put(state{token_approvals[tokenId] = to})

  public stateful function transfer_from(from : address, to : address, tokenId : token_id) =
    require(is_approved_or_owner(Call.caller, tokenId), "Not owner or not approved")
    
    clear_approval(from, tokenId)
    remove_token_from(from, tokenId)
    add_token_to(to, tokenId)

  public stateful function set_approval_for_all(to : address, approved : bool) =
    put(state{operator_approvals[Call.caller = {}][to] = approved})

  private stateful function add_token_to(to : address, tokenId : token_id) = 
    put(state{
      token_owner[tokenId] = to,
      owned_tokens_count[to] = SafeMath.add(Map.lookup_default(to, state.owned_tokens_count, 0), 1)})

  private stateful function remove_token_from(from : address, tokenId : token_id) =
    only_token_owner(from, tokenId)
    put(state{
      token_owner[tokenId] = #0,
      owned_tokens_count[from] = SafeMath.sub(Map.lookup_default(from, state.owned_tokens_count, 0), 1)})

  private stateful function clear_approval(owner : address, tokenId : token_id) =
    only_token_owner(owner, tokenId)
    put(state{token_approvals = Map.delete(tokenId, state.token_approvals)})

  private stateful function remove_token_metadata(tokenId : token_id) = 
    put(state{token_uris = Map.delete(tokenId, state.token_uris)})

  private function require(expression : bool, error : string) =
    if(!expression) 
      abort(error)

  private function only_owner(owner : address) =
    require(owner == state.owner, "Only owner can mint!")

  private function only_token_owner(owner : address, tokenId : token_id) =
    require(owner == Map.lookup_default(tokenId, state.token_owner, #0), "Only token owner can transfer!")

  private function is_approved_or_owner(spender : address, tokenId : token_id) : bool = 
    let owner : address = owner_of(tokenId)
    get_approved(tokenId) == spender || owner == spender || is_approved_for_all(owner, spender)