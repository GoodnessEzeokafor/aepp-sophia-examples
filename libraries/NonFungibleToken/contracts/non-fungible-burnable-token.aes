include "math.aes"

contract NonFungibleBurnable =
  record state = { 
    name              : string,
    symbol            : string,
    owner             : address,
    owned_tokens_count : map(address, int),
    token_owner        : map(int, address),
    token_approvals    : map(int, address),
    operator_approvals : map(address, map(address, bool))}

  public stateful function  init(name : string, symbol : string) = {
  	name = name,
  	symbol = symbol,
    owner = Call.caller,
  	owned_tokens_count = {},
  	token_owner = {},
  	token_approvals = {},
    operator_approvals = {}}

  public function name() : string = 
    state.name

  public function symbol() : string = 
    state.symbol

  public function balance_of(token_owner : address) : int = 
    Map.lookup_default(token_owner, state.owned_tokens_count, 0) // lookupByAddress(token_owner, state.owned_tokens_count, 0)

  public function owner_of(token_id : int) = 
    Map.lookup_default(token_id, state.token_owner, #0) // lookupById(token_id, state.token_owner, #0)

  public function get_approved(token_id : int) : address = 
    Map.lookup_default(token_id, state.token_approvals, #0) // lookupById(token_id, state.token_approvals, #0)

  public function is_approved_for_all(owner : address, operator : address) : bool = 
    // state.operator_approvals[owner][operator]
    let operators = Map.lookup_default(owner, state.operator_approvals, {})
    Map.lookup_default(operator, operators, false)

  public stateful function burn(token_id : int) : bool = 
    only_token_owner(Call.caller, token_id) 
    remove_token_from(Call.caller, token_id)
    true

  public stateful function approve(token_id : int, to : address) : bool =
    let owner : address = owner_of(token_id)
    
    require(to != Call.caller, "Receiver can't be same as sender")
    require(Call.caller == owner || is_approved_for_all(owner, Call.caller), "Not owner or not approved")
    
    put(state{token_approvals = state.token_approvals{[token_id] = to}})

    true

  public stateful function transferFrom(from : address, to : address, token_id : int) =
    require(is_approved_or_owner(Call.caller, token_id), "Caller isn't approved or owner")
    
    clear_approval(from, token_id)
    remove_token_from(from, token_id)
    add_token_to(to, token_id)

  public stateful function set_approval_for_all(to : address, approved : bool) : bool =
    // ensure_allowed(Call.caller) remove me
    put(state{operator_approvals[Call.caller = {}][to] = approved})
    true
  
  private function check_token_exists(token_id : int) : bool =
    switch(Map.lookup(token_id, state.token_owner))
      None    => false
      Some(x) => true

  private function ensure_allowed(key : address) =
    switch(Map.lookup(key, state.operator_approvals))
      None => put(state{operator_approvals[key] = {}})
      Some(_) => ()

  private stateful function add_token_to(to : address, token_id : int) = 
    put(state{token_owner = state.token_owner{[token_id] = to}})
    // put(state{owned_tokens_count[to] = add(lookupByAddress(to, state.owned_tokens_count, 0), 1)}) // Map.lookup_default(token_owner, state.owned_tokens_count, 0)
    put(state{owned_tokens_count[to] = SafeMath.add(Map.lookup_default(to, state.owned_tokens_count, 0), 1)}) 

  private stateful function remove_token_from(from : address, token_id : int) =
    put(state{token_owner = state.token_owner{[token_id] = #0}})
    put(state{owned_tokens_count[from] = SafeMath.sub(Map.lookup_default(from, state.owned_tokens_count, 0), 1)})

  private stateful function clear_approval(from : address, token_id : int) : bool = 
    put(state{token_approvals = state.token_approvals{[token_id] = #0}})
    true

  // private function lookupByAddress(k : address, m, v) =
  // 	switch(Map.lookup(k, m))
	//     None    => v
	//     Some(x) => x

  // private function lookupById(k : int, m, v) =
  // 	switch(Map.lookup(k, m))
	//     None    => v
	//     Some(x) => x

  // private function add(_a : int, _b : int) : int =
  //   let c : int = _a + _b
  //   require(c >= _a, "Error")
  //   c

  // private function sub(_a : int, _b : int) : int =
  //   require(_b =< _a, "Error")
  //   _a - _b

  private function require(b : bool, err : string) =
    if(!b) 
      abort(err)

  private function onlyOwner(owner : address) =
    if(owner != state.owner) 
      abort("Only owner can mint!")

  private function only_token_owner(owner : address, token_id : int) =
    if(owner != Map.lookup_default(token_id, state.token_owner, #0)) 
      abort("Only token owner can transfer!")

  private function is_approved_or_owner(spender : address, token_id : int) : bool = 
    let owner : address = owner_of(token_id)
    get_approved(token_id) == spender || owner == spender || is_approved_for_all(owner, spender)