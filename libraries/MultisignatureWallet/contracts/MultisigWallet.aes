contract Voting =
    public function vote   : () => bool
    public function revoke : () => bool
    public function result : () => int

contract MultiSigWallet =
    record state = { 
        owner: address,
        configured: bool, 
        owners_count: int,
        transactions_count: int,
        required: int,
        m_index_owner: map(int, address),
        m_owner_index: map(address, int),
        m_index_transaction: map(int, transaction),
        m_remove_owner_votes: map(address, int),
        m_add_owner_votes: map(address, int),
        m_remove_owner_confirmations: map((address,address), bool),
        m_add_owner_confirmations: map((address,address), bool), 
        m_change_requirement_votes: map((int,address), bool),
        m_change_requirement_confirmations: map(int, int),
        m_tx_confirmations: map((int,address), bool)} 
    
    record transaction = { 
        id: int,
        confirmations: int,
        method: string}

    datatype method = 
        Vote   |  
        Revoke | 
        Result
          
    public stateful function init() = 
        { required = 1,
          owner = Call.caller,
          configured = false,
          owners_count = 0,
          transactions_count = 0,
          m_index_owner = {},
          m_owner_index = {},
          m_index_transaction = {},
          m_remove_owner_votes = {},
          m_add_owner_votes = {},
          m_tx_confirmations = {},
          m_add_owner_confirmations = {},
          m_remove_owner_confirmations = {},
          m_change_requirement_votes = {},
          m_change_requirement_confirmations = {}}

    public stateful function init_owner(owner : address) = 
        only_owner()
        only_not_configured()

        add_new_owner(owner)

    public stateful function configure() = 
        only_owner()
        require(state.required =< state.owners_count, "'Required' should be lower than owners count!")

        put(state{configured = true})

    public stateful function vote_change_requirement(new_required: int, vote: bool) =
        only_owners()
        // validate requirements
        validate_requirement(new_required, state.owners_count)
        // is caller already voted
        // has_voted_for_requirement_change(new_required, Call.caller)
        require(!Map.lookup_default((new_required, caller), state.m_change_requirement_votes, false), "Your vote has been already submitted.")

        put(state{m_change_requirement_votes[(new_required, Call.caller)] = true})

        if(vote)
            // put(state{m_change_requirement_confirmations[new_required] =  get_requirement_confirmations(new_required)
            put(state{m_change_requirement_confirmations[new_required] =  Map.lookup_default(new_required, state.m_change_requirement_confirmations, 0) + 1})

        // if(get_requirement_confirmations(new_required) >= state.required)
        if(Map.lookup_default(new_required, state.m_change_requirement_confirmations, 0) >= state.required)
            put(state{m_change_requirement_confirmations[new_required] = 0})
            put(state{required = new_required})
            reset_requirement_vote(new_required, 1, state.owners_count)

    public stateful function vote_add_owner(owner : address) =
        only_configured()
        only_owners()
        is_not_owner(owner)
        has_voted_for_owner_addition(owner)
        
        //put(state{m_add_owner_votes[owner] = get_value_address_int(owner, state.m_add_owner_votes) + 1})
        put(state{m_add_owner_votes[owner] = Map.lookup_default(owner, state.m_add_owner_votes, 0) + 1})
        put(state{m_add_owner_confirmations[(owner,Call.caller)] = true}) // set this value to true because current owner make a vote 

        //if(get_value_address_int(owner, state.m_add_owner_votes) >= state.required)
        if(Map.lookup_default(owner, state.m_add_owner_votes, 0) >= state.required)
            add_new_owner(owner)
            
    public stateful function vote_remove_owner(owner: address) =
        only_configured()
        only_owners()
        is_owner_exists(owner)
        has_voted_for_owner_removal(owner)
        
        //put(state{m_remove_owner_votes[owner] = get_value_address_int(owner, state.m_remove_owner_votes) + 1})
        put(state{m_remove_owner_votes[owner] = Map.lookup_default(owner, state.m_remove_owner_votes, 0) + 1})
        put(state{m_remove_owner_confirmations[(owner,Call.caller)] = true})

        //if(get_value_address_int(owner, state.m_remove_owner_votes) >= state.required)
        if(Map.lookup_default(owner, state.m_remove_owner_votes, 0) >= state.required)
            removeOwner(owner)

    public function get_confirmations(tx_id: int) : int =
        only_configured()

        state.m_index_transaction[tx_id].confirmations

    public stateful function add_transaction(method: string) : int = 
        only_configured()
        only_owners()
        require(validate_method_name(method), "Invalid method name.")

        let tx: transaction = {
            id = state.transactions_count,
            confirmations = 0,
            method = method}

        put(state{m_index_transaction = state.m_index_transaction{[state.transactions_count] = tx}})
        put(state{transactions_count = state.transactions_count + 1})  

        tx.id

    public stateful function approve(tx_id: int, voting_contract: Voting) = // pass contract address
        only_configured()
        only_owners()
        has_voted_tx_approved(tx_id)

        let transaction: transaction = state.m_index_transaction[tx_id]

        let transaction' = transaction { 
            id = transaction.id, 
            confirmations = transaction.confirmations + 1, 
            method = transaction.method }

        put(state{m_tx_confirmations[(tx_id,Call.caller)] = true})
        put(state{m_index_transaction = state.m_index_transaction{[tx_id] = transaction'}})

        // if there are needed votes execute tx
        if(transaction'.confirmations >= state.required)
            execute_transaction(tx_id, voting_contract)

    private stateful function execute_transaction(tx_id: int, votingContract: Voting) = 
        only_configured()
        only_owners()
        valid_requirement()

        let transactio: transaction = state.m_index_transaction[tx_id]
        require(transaction.confirmations >= state.required, "Not enough votes!")
        
        switch(transaction.method)
            "Vote"   => votingContract.vote()
            "Revoke" => votingContract.revoke()

        let transaction' = transaction { 
            id = transaction.id, 
            confirmations = 0, 
            method = transaction.method }
    
        put(state{m_index_transaction = state.m_index_transaction{[tx_id] = transaction'}})

        reset_approve_tx_vote(tx_id, 1, state.owners_count)

    private function validate_method_name(method: string) : bool =
        switch(method)
            "Vote" => true
            "Revoke" => true
            _ => false

    private stateful function add_new_owner(owner : address) =
        require(owner != Contract.address, "Address can't be same as contract address")
          
        put(state{m_add_owner_votes[owner] = 0})
        put(state{owners_count = state.owners_count + 1})    
        put(state{m_index_owner = state.m_index_owner{[state.owners_count] = owner}})
        put(state{m_owner_index = state.m_owner_index{[owner] = state.owners_count}})

        reset_add_owner_vote(owner, 1, state.owners_count)

    private function only_owner() =
        require(Call.caller == state.owner, "Only owner")
        
    private function only_owners() =
        require(Map.lookup_default(Call.caller, state.m_owner_index, 0) != 0, "Caller is not an owner.")

    // private function lookupByAddress(key : address, _map, defaultValue : int) =
    //     switch(Map.lookup(key, _map))
    //         None    => defaultValue
    //         Some(x) => x

    // private function lookupById(k : int, m, v) =
    //     switch(Map.lookup(k, m))
    //         None    => v
    //         Some(x) => x

    private function valid_requirement() =
        require(state.owners_count > 0, "Owners count should be greater than zero")
        require(state.owners_count =< state.required, "Owners count can't be greater than required")
        require(state.required > 0, "Required should be greater than zeo")

    private function only_not_configured() =
        require(!state.configured, "Only not configured")

    private function only_configured() =
        require(state.configured, "Only configured")

    private function require(expression : bool, error : string) =
        if(!expression) 
            abort(error)

    // private function add(_a : int, _b : int) : int =
    //     let c : int = _a + _b
    //     require(c >= _a, "Math Error")
    //     c

    // private function sub(_a : int, _b : int) : int =
    //     require(_b =< _a, "Math Error")
    //     _a - _b

    // private function get_value_from_map_tuple(new_owner: address, current_owner: address, map') : bool =
    //     switch(Map.lookup((new_owner, current_owner), map'))
    //         None    => false
    //         Some(x) => x

    // private function get_value_from_map_tuple_int_address(tx_id: int, current_owner: address, map') : bool =
    //     switch(Map.lookup((tx_id, current_owner), map'))
    //         None    => false
    //         Some(x) => x

    // private function get_value_address_int(new_owner: address, map') : int =
    //     switch(Map.lookup(new_owner, map'))
    //         None    => 0
    //         Some(x) => x

    private function is_owner_exists(owner': address) =
        // let index = 
        //     switch (Map.lookup(owner', state.m_owner_index))
        //         None => 0
        //         Some(x) => x

        // require(index > 0, "Address is not an owner!")
        
        require(Map.lookup_default(owner', state.m_owner_index, 0) > 0, "Address is not an owner!")

        // index

    private function calculate_minimum_required(current_require) : int =
        switch(current_require =< 1)
            true => 1
            false => current_require - 1

    private function validate_requirement(required: int, owner_count: int) =
        require(required =< owner_count && required > 0 && owner_count > 0, "Invalid requirements.")
    
    // private function is_owner_voted_for_requirement(new_required: int, voter : address) : bool = 
    //     switch(Map.lookup((new_required, voter), state.m_change_requirement_votes))
    //             None    => false
    //             Some(x) => x

    private stateful function reset_requirement_vote(required: int, current_owner_index: int, max_index: int ) = 
        if(current_owner_index =< max_index)
            put(state{m_change_requirement_votes[(required, state.m_index_owner[current_owner_index])] = false})
            // Map.delete((required, state.m_index_owner[current_owner_index]), state.m_change_requirement_votes)
            put(state{m_change_requirement_votes = Map.delete((required, state.m_index_owner[current_owner_index]), state.m_change_requirement_votes)})
            reset_requirement_vote(required, current_owner_index + 1, max_index)

    private stateful function reset_add_owner_vote(owner': address, current_owner_index: int, max_index : int) = 
        if(current_owner_index =< max_index)
            put(state{m_add_owner_confirmations[(owner', state.m_index_owner[current_owner_index])] = false})
            // Map.delete((owner', state.m_index_owner[current_owner_index]), state.m_add_owner_confirmations)
            put(state{m_add_owner_confirmations = Map.delete((owner', state.m_index_owner[current_owner_index]), state.m_add_owner_confirmations)})
            reset_add_owner_vote(owner', current_owner_index + 1, max_index)

    private stateful function reset_remove_owner_vote(owner': address, current_owner_index: int, max_index: int) = 
        if(current_owner_index =< max_index)
            put(state{m_remove_owner_confirmations[(owner', state.m_index_owner[current_owner_index])] = false})
            // Map.delete((owner', state.m_index_owner[current_owner_index]), state.m_remove_owner_confirmations)
            put(state{m_remove_owner_confirmations = Map.delete((owner', state.m_index_owner[current_owner_index]), state.m_remove_owner_confirmations)})
            reset_remove_owner_vote(owner', current_owner_index + 1, max_index)

    private stateful function reset_approve_tx_vote(tx_id: int, current_owner_index: int, max_index: int ) = 
        if(current_owner_index =< max_index)
            put(state{m_tx_confirmations[(tx_id, state.m_index_owner[current_owner_index])] = false})
            //Map.delete((tx_id, state.m_index_owner[current_owner_index]), state.m_tx_confirmations)
            put(state{m_tx_confirmations = Map.delete((tx_id, state.m_index_owner[current_owner_index]), state.m_tx_confirmations)})
            reset_approve_tx_vote(tx_id, current_owner_index + 1, max_index)

    // private function has_voted_for_requirement_change(new_required: int, caller: address) =
    //     require(!is_owner_voted_for_requirement(new_required, caller), "Your vote has been already submitted.")
        
        

    // private function get_requirement_confirmations(key: int) : int =
    //     switch(Map.lookup(key, state.m_change_requirement_confirmations))
    //         None => 0
    //         Some(x) => x

    private function is_not_owner(new_owner: address) =
        // let index =
        //     switch(Map.lookup(new_owner, state.m_owner_index))
        //         None => 0
        //         Some(x) => x
        
        require(Map.lookup_default(new_owner, state.m_owner_index, 0) == 0, "Suggested owner is already owner!")

    private function has_voted_for_owner_addition(new_owner : address) =
        // require(!get_value_from_map_tuple(new_owner, Call.caller, state.m_add_owner_confirmations), "Your vote has been already submitted.")
        require(!Map.lookup((new_owner, Call.caller), state.m_add_owner_confirmations, false), "Your vote has been already submitted.")
        

    private function has_voted_for_owner_removal(owner: address) =
        // require(!get_value_from_map_tuple(owner, Call.caller, state.m_remove_owner_confirmations), "Your vote has been already submitted.")
        require(!Map.lookup_default((owner, Call.caller), state.m_remove_owner_confirmations, false), "Your vote has been already submitted.")

    private function has_enough_remove_votes(owner: address) =
        //require(get_value_address_int(owner, state.m_remove_owner_votes) >= state.required, "Not enough votes!")
        require(Map.lookup_default(owner, state.m_remove_owner_votes, 0) >= state.required, "Not enough votes!")

    private stateful function removeOwner(owner: address) =
        only_configured()
        only_owners()
        has_enough_remove_votes(owner)

        // swap last owner with deleted one
        let owner_index = state.m_owner_index[owner]
        let last_added_owner = state.m_index_owner[state.owners_count]
        put(state{m_owner_index[last_added_owner] = owner_index})
        put(state{m_index_owner[owner_index] = last_added_owner})

        // Map.delete is not working correctly
        put(state{m_owner_index[owner] = 0}) 
        put(state{m_remove_owner_votes[owner] = 0})

        //Map.delete(owner, state.m_remove_owner_votes)
        put(state{m_remove_owner_votes = Map.delete(owner, state.m_remove_owner_votes)})

        // Map.delete(owner, state.m_owner_index)
        put(state{m_owner_index = Map.delete(owner, state.m_owner_index)})

        put(state{owners_count = state.owners_count - 1})    
        put(state{required = calculate_minimum_required(state.required)})

        reset_remove_owner_vote(owner, 1, state.owners_count)

    private function has_voted_tx_approved(tx_id: int) =
        //require(!get_value_from_map_tuple_int_address(tx_id, Call.caller, state.m_tx_confirmations), "Your vote has been already submitted.")
        require(!Map.lookup_default(tx_id, Call.caller, state.m_tx_confirmations, false), "Your vote has been already submitted.")
