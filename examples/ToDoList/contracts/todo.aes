contract ToDoManager =

  record todo = {
    name: string,
    is_completed: bool}

  record state = {
    m_user_todos: map(address, map(int, todo)),
    m_user_todo_count: map(address, int)}


  public stateful function init() =
    { m_user_todos = {},
      m_user_todo_count = {}}


  public function get_caller() : address =
    Call.caller

  public function get_todo_count(user: address) : int =
    switch(Map.lookup(user, state.m_user_todo_count))
      None => 0
      Some(x) => x

  public stateful function add_todo(todo_name: string) =
    let new_todo : todo = {
      name = todo_name,
      is_completed = false}

    let index = get_todo_count(Call.caller) + 1

    create_nested_map_if_not_exists(Call.caller)

    put(state{m_user_todos[Call.caller][index] = new_todo})
    put(state{m_user_todo_count[Call.caller] = index})

  private stateful function create_nested_map_if_not_exists(user: address) : bool =
    let is_exists = is_nested_map_exists(user)
    if(!is_exists)
      put(state{m_user_todos[Call.caller] = {}})
      true
    else
      false

  private stateful function is_nested_map_exists(user: address) : bool =
    switch(Map.lookup(user, state.m_user_todos))
      None => false
      Some(x) => true

  public stateful function edit_todo_state(todo_index: int, _is_completed: bool) =

    let current_todo : todo = private_get_todo_by_index(Call.caller, todo_index)
    let edited_todo : todo = {
      name = current_todo.name,
      is_completed = _is_completed}

    put(state{m_user_todos[Call.caller][todo_index] = edited_todo})

  public stateful function edit_todo_name(todo_index: int, todo_name: string) =

    let current_todo : todo = private_get_todo_by_index(Call.caller, todo_index)
    let edited_todo : todo = {
      name = todo_name,
      is_completed = current_todo.is_completed}

    put(state{m_user_todos[Call.caller][todo_index] = edited_todo})

  public function get_todo_by_index(user: address, index: int) : string =
    let todos: map(int,todo) = get_todos_by_user(user)
    
    let current_todo = get_todo(index, todos)
    if (current_todo.name == "")
      ""
    else
      let name = String.concat("Name: ", current_todo.name)
      let name_with_delimeter = String.concat(name, " | Is completed: ")
      let todo_as_string = String.concat(name_with_delimeter, convert_bool_to_string(current_todo.is_completed))

      todo_as_string

  public function get_todos() : list(string) =
    // ["Name: first todo | Is completed: false", "Name: second todo | Is completed: true"]
    let numberOfTodos = get_todo_count(Call.caller)
    let collection = []
    let allTodos = collectData(Call.caller, collection, 0, numberOfTodos)
    allTodos

  private function collectData(user: address, allTodos: list(string), startIndex: int, endIndex: int) : list(string) =
      if(startIndex =< endIndex)
        let todoData = get_todo_by_index(user, startIndex)
        let tempCollection = todoData :: allTodos
        collectData(user, tempCollection, startIndex + 1, endIndex)
      else
        allTodos


  private function convert_bool_to_string(expression: bool) : string =
    switch(expression)
      true => "true"
      false => "false"

  private function private_get_todo_by_index(user: address, index: int) : todo =
    let todos: map(int,todo) = get_todos_by_user(user)
    
    get_todo(index, todos)

  private function get_todos_by_user(user: address) : map(int, todo) =
    switch(Map.lookup(user, state.m_user_todos))
      None => {}
      Some(x) => x

  private function get_todo(index: int, todos: map(int, todo)) : todo =

    let new_todo : todo = {
      name = "",
      is_completed = false}

    switch(Map.lookup(index, todos))
      None => new_todo
      Some(x) => x