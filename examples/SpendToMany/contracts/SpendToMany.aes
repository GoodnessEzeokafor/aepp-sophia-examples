contract SpendToMany =
  // {[publicKey1_in_hex] = some_tokens , ... [publicKeyN_in_hex] = some_tokens}
  function spend_to_many(data_map : map(address, int)) =
    let tuples_list = Map.to_list(data_map) 
    require(validate_expenses(Map.to_list(data_map)), "The balance given to perform this action is not sufficient")
    let sent_tokens = spend_to_many'(tuples_list, 0, Call.value)
    if(Call.value - sent_tokens > 0)
      Chain.spend(Call.caller, Call.value - sent_tokens)   //return excess amount of tokens back to the caller
    String.concat(Int.to_str(sent_tokens), "  tokens are sent!")

  
  private function spend_to_many'(list, acc, amount_left) : int = 
    switch(list)
      [] => acc
      (address, tokens) :: l' =>
        require(amount_left >= tokens, "Not enough tokens! Aborting") 
        Chain.spend(address,tokens) 
        spend_to_many'(l', acc + tokens, amount_left - tokens)


  private function validate_expenses(tuples_list) : bool = //comparing possible expenses and given tokens
    sum((x) => x, preprocess_expenses(tuples_list,[])) =< Call.value 

  private function preprocess_expenses(tuples_list, acc) : list(int)= 
    switch(tuples_list)
      [] => acc
      (_ , tokens) :: l' =>
        preprocess_expenses(l', tokens :: acc)
 
  private function sum(f : 'a => int, l : list('a)) : int =
    foldr((x, y) => x + y, 0, map(f, l))

  private function foldr(f : (('a, 'b) => 'b), z: 'b, l : list('a)) : 'b =
    switch(l)
      [] => z
      e :: l' => f(e, foldr(f, z, l'))
  function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  private function require(condition : bool, errstr : string) =
    if(!condition)
      abort(errstr)